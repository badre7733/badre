<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Traffic Racer - Three.js (mejorado)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; overflow:hidden; background:#0b0b0b; color:#fff; font-family:system-ui,Segoe UI,Roboto,Arial; }
    #ui {
      position: absolute; left:12px; top:12px; z-index: 20;
      background: rgba(0,0,0,0.45); padding:10px 12px; border-radius:8px;
      backdrop-filter: blur(4px);
      display:flex; gap:12px; align-items:center;
    }
    #score{ font-weight:700; margin-left:6px; }
    #controls { position: absolute; right:12px; top:12px; z-index:20; display:flex; gap:8px; align-items:center; }
    button { background:#222; color:#fff; border:1px solid #444; padding:8px 10px; border-radius:6px; cursor:pointer; }
    #canvas { display:block; width:100vw; height:100vh; }
    #message {
      position: absolute; bottom: 12px; left: 12px; z-index: 20;
      background: rgba(0,0,0,0.45); padding:8px 12px; border-radius:8px; font-size:13px;
    }
    #minimap {
      position:absolute; right:12px; bottom:12px; z-index:20;
      width:180px; height:220px; background: rgba(0,0,0,0.45); border-radius:8px; padding:8px;
      display:flex; flex-direction:column; gap:6px;
    }
    #minimap canvas { background: #071017; border-radius:4px; width:100%; height:160px; }
    .touch-pad { position:absolute; left:0; bottom:0; right:0; top:0; z-index:5; }
    .small { font-size:12px; opacity:0.9; }
    #gameover {
      position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:30;
      background: rgba(0,0,0,0.6); color:#fff; font-size:20px;
    }
    #gameover .box { background:#111; padding:20px; border-radius:10px; text-align:center; min-width:260px; }
  </style>
</head>
<body>
  <div id="ui">
    <div>
      <div style="font-weight:700">Traffic Racer — Mejorado</div>
      <div class="small">A / ← → / Flechas | Tocar para mover</div>
    </div>
    <div> Puntos: <span id="score">0</span></div>
    <div id="speedLabel">Vel: <span id="speedVal">0.6</span></div>
  </div>

  <div id="controls">
    <button id="pauseBtn">Pausa</button>
    <button id="restartBtn">Reiniciar</button>
    <button id="toggleModelBtn">Toggle Modelo</button>
  </div>

  <div id="message">Consejo: usa Live Server (VSCode) si tienes problemas con la carga del modelo GLB.</div>

  <div id="minimap">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div class="small">Minimapa</div>
      <div class="small">Tráfico: <span id="trafficCount">0</span></div>
    </div>
    <canvas id="miniCanvas" width="300" height="240"></canvas>
    <div class="small">Toque/arrastre para mover. Espacio: reiniciar.</div>
  </div>

  <div id="gameover"><div class="box"><div id="goText" style="font-weight:700;font-size:22px">¡CHOCASTE!</div><div>Puntuación final: <b id="finalScore">0</b></div><div style="margin-top:12px"><button id="goRestart">Reintentar</button></div></div></div>

  <canvas id="canvas"></canvas>

  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

  // -----------------------------
  // CONFIG
  // -----------------------------
  const MODEL_URL = 'https://threejs.org/examples/models/gltf/ferrari.glb'; // opcional; fallback geométrico si falla
  const canvas = document.getElementById('canvas');
  const scoreEl = document.getElementById('score');
  const speedValEl = document.getElementById('speedVal');
  const trafficCountEl = document.getElementById('trafficCount');
  const miniCanvas = document.getElementById('miniCanvas');
  const miniCtx = miniCanvas.getContext('2d');
  const messageEl = document.getElementById('message');

  // -----------------------------
  // THREE: escena, cámara y renderer
  // -----------------------------
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b0b0b, 10, 120);

  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 500);
  camera.position.set(0, 6, 14);

  // Luzes
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
  hemi.position.set(0,50,0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(-10,20,10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  // -----------------------------
  // Suelo / carretera
  // -----------------------------
  const roadWidth = 8;
  const roadLength = 260;
  const groundMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.9 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(roadWidth, roadLength, 1,1), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.z = -roadLength/2 + 10;
  ground.receiveShadow = true;
  scene.add(ground);

  // lineas centrales (repeat)
  const lines = [];
  const lineGeom = new THREE.PlaneGeometry(0.25, 8);
  const lineMat = new THREE.MeshBasicMaterial({ color:0xffffa0 });
  for (let i = -30; i < 120; i += 10) {
    const L = new THREE.Mesh(lineGeom, lineMat);
    L.rotation.x = -Math.PI/2;
    L.position.set(0, 0.01, i);
    scene.add(L);
    lines.push(L);
  }

  // -----------------------------
  // Jugador y tráfico
  // -----------------------------
  const lanes = [-2.5, 0, 2.5];
  let player = null;
  let playerBBox = new THREE.Box3();
  let playerUseModel = true;
  let modelTemplate = null;

  // Pooling para tráfico
  const trafficPool = [];
  const activeTraffic = [];

  // Parámetros del juego
  let baseSpeed = 0.6;
  let speed = baseSpeed;
  let score = 0;
  let running = true;
  let lastSpawnZ = -60;
  let spawnInterval = 12; // distancia en Z entre spawns
  let lastTime = performance.now();

  // Controles
  const input = { left:false, right:false, pointerDown:false, pointerX:0, pointerStartX:0 };
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
    if (e.code === 'Space') restartGame();
    if (e.key === 'p') togglePause();
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
  });

  // Touch / pointer controls (drag left-right)
  renderer.domElement.addEventListener('pointerdown', (e) => {
    input.pointerDown = true;
    input.pointerStartX = e.clientX;
    input.pointerX = e.clientX;
  });
  window.addEventListener('pointermove', (e) => {
    if (!input.pointerDown) return;
    const dx = e.clientX - input.pointerStartX;
    // convertir dx a objetivo de X (sensible)
    const pct = dx / window.innerWidth;
    const targetX = pct * (roadWidth*0.7);
    if (player) player.position.x = THREE.MathUtils.clamp(targetX, -roadWidth/2 + 0.8, roadWidth/2 - 0.8);
  });
  window.addEventListener('pointerup', () => { input.pointerDown = false; });

  // -----------------------------
  // Audio simple (WebAudio) para efectos
  // -----------------------------
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function beep(frequency = 440, duration = 0.08, type='sine', gain=0.05) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = frequency;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + duration);
  }
  function crashSound() {
    if (!audioCtx) return;
    // ruido corto con envolvente
    const bufferSize = audioCtx.sampleRate * 0.2;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const g = audioCtx.createGain();
    g.gain.value = 0.3;
    noise.connect(g); g.connect(audioCtx.destination);
    noise.start();
    noise.stop(audioCtx.currentTime + 0.2);
  }

  // -----------------------------
  // Util: bounding box recalculado
  // -----------------------------
  function computeBBox(obj) {
    const b = new THREE.Box3().setFromObject(obj);
    return b;
  }

  // -----------------------------
  // Crear jugador (modelo o fallback)
  // -----------------------------
  function createPlayerFromModel(sceneModel) {
    if (player) scene.remove(player);
    player = sceneModel.clone(true);
    player.scale.setScalar(0.01); // modelo del ejemplo es grande
    player.rotation.y = Math.PI;
    player.position.set(0, 0, 6);
    player.traverse((c) => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
    scene.add(player);
    playerBBox = computeBBox(player);
  }
  function createPlayerFallback() {
    if (player) scene.remove(player);
    const g = new THREE.BoxGeometry(2.2,0.9,4.2);
    const m = new THREE.MeshStandardMaterial({ color:0xff3333, metalness:0.2, roughness:0.6 });
    player = new THREE.Mesh(g,m);
    player.position.set(0,0.45,6);
    player.castShadow = true;
    scene.add(player);
    playerBBox = computeBBox(player);
  }

  // -----------------------------
  // Cargar modelo GLTF (fallback si falla)
  // -----------------------------
  const loader = new GLTFLoader();
  loader.load(MODEL_URL, (gltf) => {
    console.log('Modelo GLB cargado OK.');
    modelTemplate = gltf.scene;
    modelTemplate.traverse((c) => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
    try {
      createPlayerFromModel(modelTemplate);
    } catch (e) {
      console.warn('No se pudo instanciar modelo, uso fallback.', e);
      createPlayerFallback();
    }
  }, (xhr) => {
    // progreso
    if (xhr && xhr.total) {
      const pct = (xhr.loaded / xhr.total * 100).toFixed(0);
      messageEl.textContent = `Cargando modelo: ${pct}%`;
    }
  }, (err) => {
    console.warn('Error cargando GLB (posible CORS o 404). Se usa fallback.', err);
    messageEl.textContent = 'No se cargó el modelo (fallback geométrico activo). Usa Live Server si quieres probar el GLB.';
    createPlayerFallback();
    modelTemplate = null;
  });

  // Opcional: botón para alternar usar modelo o fallback
  document.getElementById('toggleModelBtn').addEventListener('click', () => {
    playerUseModel = !playerUseModel;
    if (playerUseModel && modelTemplate) createPlayerFromModel(modelTemplate);
    else createPlayerFallback();
  });

  // -----------------------------
  // Pool / Spawn tráfico (mejorado)
  // -----------------------------
  function createTrafficMesh() {
    // intento usar el modelo si existe, sino caja simplificada
    if (modelTemplate) {
      const m = modelTemplate.clone(true);
      m.scale.setScalar(0.01);
      m.rotation.y = Math.PI;
      m.traverse((c) => {
        if (c.isMesh && c.material && c.material.color) {
          c.material = c.material.clone();
          const tint = new THREE.Color().setHSL(Math.random(), 0.6, 0.5);
          c.material.color.lerp(tint, 0.6);
        }
      });
      m.castShadow = true;
      return m;
    } else {
      const geom = new THREE.BoxGeometry(2,0.9,4);
      const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(),0.6,0.5) });
      const mm = new THREE.Mesh(geom, mat);
      mm.castShadow = true;
      return mm;
    }
  }

  function getTrafficFromPool() {
    if (trafficPool.length > 0) return trafficPool.pop();
    const mesh = createTrafficMesh();
    scene.add(mesh);
    return mesh;
  }

  function releaseTraffic(mesh) {
    // reset simple
    mesh.position.set(0,-100,0);
    trafficPool.push(mesh);
  }

  function spawnTrafficAt(zPos = -100) {
    const mesh = getTrafficFromPool();
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    mesh.position.set(lane, 0, zPos);
    mesh.userData.speedMult = 1 + Math.random()*0.35; // variar velocidad relativa
    activeTraffic.push(mesh);
  }

  // inicial spawn
  for (let i = 0; i < 10; i++) {
    spawnTrafficAt(-30 - i * spawnInterval + Math.random()*6);
  }

  // -----------------------------
  // Partículas simples para choque
  // -----------------------------
  const particles = [];
  function makeCrashParticles(pos, count = 16) {
    for (let i = 0; i < count; i++) {
      const g = new THREE.SphereGeometry(0.06,6,6);
      const m = new THREE.MeshBasicMaterial({ color: 0xffffff * Math.random() });
      const p = new THREE.Mesh(g,m);
      p.position.copy(pos);
      p.userData.vel = new THREE.Vector3((Math.random()-0.5)*6, Math.random()*3, (Math.random()-0.5)*6);
      p.userData.life = 0.6 + Math.random()*0.6;
      scene.add(p);
      particles.push(p);
    }
  }

  // -----------------------------
  // Colisión
  // -----------------------------
  function checkCollisions() {
    if (!player) return false;
    playerBBox = computeBBox(player);
    for (let i = activeTraffic.length-1; i >= 0; i--) {
      const t = activeTraffic[i];
      const tb = computeBBox(t);
      if (tb.intersectsBox(playerBBox)) {
        // choque
        return { hit: true, mesh: t };
      }
    }
    return { hit:false };
  }

  // -----------------------------
  // Minimapa render (2D)
  // -----------------------------
  function renderMinimap() {
    miniCtx.clearRect(0,0,miniCanvas.width,miniCanvas.height);
    // fondo
    miniCtx.fillStyle = '#071017';
    miniCtx.fillRect(0,0,miniCanvas.width,miniCanvas.height);
    // carretera (centrada)
    const w = miniCanvas.width * 0.5;
    const x0 = (miniCanvas.width - w)/2;
    miniCtx.fillStyle = '#0d1116';
    miniCtx.fillRect(x0, 10, w, miniCanvas.height - 30);
    // player
    if (player) {
      const px = x0 + w/2 + (player.position.x / (roadWidth/2)) * (w/2) ;
      const pz = miniCanvas.height - 30 - (player.position.z / 120) * (miniCanvas.height - 60);
      miniCtx.fillStyle = '#ff4444';
      miniCtx.fillRect(px-4, pz-6, 8, 12);
    }
    // tráfico
    miniCtx.fillStyle = '#66ccff';
    for (const t of activeTraffic) {
      const tx = x0 + w/2 + (t.position.x / (roadWidth/2)) * (w/2);
      const tz = miniCanvas.height - 30 - (t.position.z / 120) * (miniCanvas.height - 60);
      miniCtx.fillRect(tx-3, tz-5, 6, 10);
    }
  }

  // -----------------------------
  // Game loop
  // -----------------------------
  function animate(now) {
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    if (running) {
      // mover líneas para dar sensación de velocidad
      for (const l of lines) {
        l.position.z += speed * 4 * dt;
        if (l.position.z > 50) l.position.z = -120;
      }

      // controlar jugador: teclado
      const moveSpeed = 8;
      if (input.left) player.position.x -= moveSpeed * dt;
      if (input.right) player.position.x += moveSpeed * dt;
      // límites
      if (player) {
        player.position.x = THREE.MathUtils.clamp(player.position.x, -roadWidth/2 + 0.8, roadWidth/2 - 0.8);
      }

      // mover tráfico hacia la cámara (z aumenta)
      for (let i = activeTraffic.length-1; i >= 0; i--) {
        const t = activeTraffic[i];
        t.position.z += speed * 60 * dt * t.userData.speedMult;
        // si pasa la cámara lo reciclamos
        if (t.position.z > 22) {
          activeTraffic.splice(i,1);
          releaseTraffic(t);
          score += 10;
          scoreEl.textContent = score;
        }
      }

      // spawn más si hace falta
      if (activeTraffic.length < 10) {
        spawnTrafficAt(lastSpawnZ - 20 + Math.random()*8);
        lastSpawnZ -= spawnInterval;
      }

      // partículas
      for (let i = particles.length-1; i >= 0; i--) {
        const p = particles[i];
        p.userData.life -= dt;
        p.position.addScaledVector(p.userData.vel, dt);
        p.userData.vel.y -= 9.8 * dt * 0.6;
        if (p.userData.life <= 0) {
          scene.remove(p);
          particles.splice(i,1);
        }
      }

      // colisiones
      const col = checkCollisions();
      if (col.hit) {
        running = false;
        // crear efecto
        const pos = col.mesh.position.clone();
        makeCrashParticles(pos, 24);
        crashSound();
        document.getElementById('finalScore').textContent = score;
        document.getElementById('gameover').style.display = 'flex';
      }

      // velocidad aumenta levemente con el score
      speed = baseSpeed + Math.min(2.5, score / 500);
      speedValEl.textContent = speed.toFixed(2);

      // actualizar el bbox del jugador
      if (player) playerBBox = computeBBox(player);
    }

    // cámara: seguir al jugador suavemente
    if (player) {
      camera.position.x += (player.position.x - camera.position.x) * 0.08;
      camera.lookAt(new THREE.Vector3(player.position.x, 1.5, player.position.z - 8));
    }

    // render
    renderer.render(scene, camera);

    // minimapa
    renderMinimap();
    trafficCountEl.textContent = activeTraffic.length;

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // -----------------------------
  // UI botones
  // -----------------------------
  document.getElementById('pauseBtn').addEventListener('click', togglePause);
  document.getElementById('restartBtn').addEventListener('click', restartGame);
  document.getElementById('goRestart').addEventListener('click', () => {
    document.getElementById('gameover').style.display = 'none';
    restartGame();
  });

  function togglePause() {
    running = !running;
    document.getElementById('pauseBtn').textContent = running ? 'Pausa' : 'Reanudar';
  }

  function restartGame() {
    // limpiar tráfico activo
    for (const t of activeTraffic) {
      scene.remove(t);
    }
    while (activeTraffic.length) activeTraffic.pop();
    // limpiar particles
    for (const p of particles) scene.remove(p);
    particles.length = 0;
    // vaciar pool de meshes del scene (pero mantener en pool)
    for (const m of trafficPool) {
      scene.remove(m);
    }
    trafficPool.length = 0;
    // reset valores
    speed = baseSpeed = 0.6;
    score = 0;
    scoreEl.textContent = score;
    lastSpawnZ = -60;
    // recrear tráfico inicial
    for (let i = 0; i < 10; i++) spawnTrafficAt(-30 - i * spawnInterval + Math.random()*6);
    // reset player
    if (player) player.position.set(0,0,6);
    running = true;
    document.getElementById('pauseBtn').textContent = 'Pausa';
    document.getElementById('gameover').style.display = 'none';
  }

  // -----------------------------
  // Responsivo
  // -----------------------------
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // -----------------------------
  // Mensajes consola para debugging y check CORS
  // -----------------------------
  window.addEventListener('error', (e) => {
    console.error('Error global:', e.error || e.message);
  });
  window.addEventListener('unhandledrejection', (ev) => {
    console.warn('Promesa rechazada:', ev.reason);
  });

  // -----------------------------
  // Notas finales y ayudas
  // -----------------------------
  console.log('%cTraffic Racer listo — recomendaciones:', 'color:#7fd6ff');
  console.log(' - Si el GLB no carga: usa Live Server (VSCode) o un servidor local.');
  console.log(' - Si quieres que ambos coches (player + traffic) usen modelos distintos o añadir sonido externo, me lo pides y lo integro.');

  // Si quieres, puedo ahora:
  // - Añadir curvas de carretera (girar la cámara y generar curvas),
  // - Añadir varios modelos distintos para tráfico (camiones, motos),
  // - Añadir físicas reales con cannon-es,
  // - Empaquetarlo para GitHub Pages (te doy los pasos).
  // Dime cuál quieres y te lo implemento.

  </script>
</body>
</html>
